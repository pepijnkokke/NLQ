\section{Lexical Ambiguity}
\label{sec:lexical-ambiguity}
In this section, we will introduce `\&' (additive conjunction), and
show how this can be used to encode lexical ambiguity.

The original framework for categorial grammar \citep{lambek1958}
already had machinery in place to deal with ambiguity; it allowed for
multiple lexical entries for each word. However, in the spirit of
wanting to deal with linguistic phenomena in a logical manner, it
seems to make more sense to absorb lexical ambiguity into the logic
itself.
\citet[][p.\ 170]{lambek1961} already does this---he adds the additive
conjunction, which he writes `$\cap$'. In
\autoref{fig:extension-lexical-ambiguity}, we describe the same
connective, but define it within the framework of focused display
calculus. The notation `\&' comes from \citet{girard1987}.

\input{fig-extension-lexical-ambiguity}

Again, we have to prove condition \textbf{C8}, in order to show that
this extension is compatible with display calculus. This time, the
proof is even easier. For L\&$_1$ and R\&:
\begin{center}
  \begin{pfbox}
    \AXC{$\vdots$}\noLine\UIC{$Γ\fCenter\struct{A}$}
    \AXC{$\vdots$}\noLine\UIC{$Γ\fCenter\struct{B}$}
    \RightLabel{R\&}
    \BIC{$Γ\fCenter\struct{A\& B}$}
    \AXC{$\vdots$}\noLine\UIC{$\struct{A}\fCenter Δ$}
    \RightLabel{L\&$_1$}
    \UIC{$\struct{A\& B}\fCenter Δ$}
    \RightLabel{Cut}
    \BIC{$Γ\fCenter Δ$}
  \end{pfbox}
  \\[1\baselineskip] $\Longrightarrow$ \\
  \begin{pfbox}
    \AXC{$\vdots$}\noLine\UIC{$Γ\fCenter\struct{A}$}
    \AXC{$\vdots$}\noLine\UIC{$\struct{A}\fCenter Δ$}
    \RightLabel{Cut}
    \BIC{$Γ\fCenter Δ$}
  \end{pfbox}
\end{center}
And likewise for L\&$_2$ and R\&.

When is this extension useful? Imagine a word like `want'. This can be
used in two different ways, with two different meanings:\\
\begin{center}
  \vspace{-1\baselineskip}
  \renewcommand{\arraystretch}{1}
  \begin{tabular}{c c}
    ``Mary wants John to leave.'' & ``Mary wants to leave.''\\
    $\WANT(\MARY,\LEAVE(\JOHN))$  & $\WANT(\MARY,\LEAVE(\MARY))$
  \end{tabular}
\end{center}
`Wants' has an implicit reflexive object: if no object is explicitly
given, it is assumed to be reflexive. Other words that show this
behaviour are words such as `to wash' and `to shave'.
Using our new connective, we can give a single definition for such
words, which takes this ambiguity into account:
\begin{alignat*}{3}
  &\text{wants}\;&:\;&\tr[(((\IV\impl\INF\impl\NP))\&(\IV\impl\INF))]\\
  &\text{wants}\;&=\;&((\lambda y\;f\;x.\WANT(x,f\;y)),(\lambda f\;x.\WANT(x,f\;x)))
\end{alignat*}
For a detailed discussion of the expressiveness of Lambek calculi
enriched with `\&' (and its dual, `$\oplus$') we refer the reader to
\citet{kanazawa1992}.

% How much of an advantage does this method have over allowing multiple
% lexical entries for a word? It is a more elegant solution for words
% such as `want', where there is an ambiguity, but where all options
% encode a similar concept---in the case of `want', in both
% interpretations, the subject wants something to be true.
% However, the similarity between the two definitions, and the
% fact that implicit reflexive objects occur with numerous transitive
% verbs, might be an indication that this is a quirk of grammar, instead
% of lexical ambiguity.\todo{Reference? Proper linguistic terminology?}
%
% Additionally, `\&' is slightly more elegant in its formalisation.
% Where \citepos{lambek1958} solution involves computing all possible
% sequents, given all possible definitions of each word, and attempting
% to find a proof for all of them. The solution using `\&' elegantly
% absorbs this traversal into the proof search. On the other hand, using
% `\&' is a lot less elegant for true lexical ambiguity. For homonyms
% like `bow'---which have many different meanings, some of them
% radically different---all of its meanings would have to be encoded in
% a single definition. However, this is easily remedied, as it is not
% hard to imagine a procedure which folds an ambiguous lexicon in the
% style of \citeauthor{lambek1958} down to an unambiguous one using
% `\&'.
