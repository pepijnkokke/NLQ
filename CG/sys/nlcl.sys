-- Barker & Shan's NLCL calculus.


-- This file implements Barker & Shan's NLCL calculus from
-- Continuation and Natural Language (2014).
-- Slight modifications have been made, in order to eliminate
-- the necessity for a `cut' rule, which speeds up the search
-- considerably.
--
-- For the proof search we have dropped the atomicity restriction on
-- the axiom rule, instead relying on the derivable axiom rule.
-- In a finite system, this would lead to spurious ambiguity, causing
-- the proof system to find multiple, semantically equivalent
-- proofs. However, in infinite systems such as NLCL, where finding a
-- proof is often still a challenge, it is a better option to use the
-- general transitivity rule, as this considerably shortens many
-- proofs.
--
-- The admissibility of the `ax' and `cut' rules depends on the
-- presence of monotonicity rules for *each* connective. In the case
-- of NLCL that means *also* of the constants (I, L, R). In our
-- version of NLCL, these are represented as the axioms mI, mL and
-- mR. However, since we are depending the derived `ax', we do not
-- need to use these rules in our proof search.


set infinite
set algebraic
set parse_with  = ⊗
set agda_name   = NL
set agda_module = Example.System.NLCL


-- Axiom.
ax′  :  A ⊢ A 


-- Rules for (⇐ , ⊗ , ⇒).
m⊗   :  A ⊢ B  →  C ⊢ D  →  A ⊗ C ⊢ B ⊗ D
m⇒   :  A ⊢ B  →  C ⊢ D  →  B ⇒ C ⊢ A ⇒ D
m⇐   :  A ⊢ B  →  C ⊢ D  →  A ⇐ D ⊢ B ⇐ C
r⇒⊗  :  B ⊢ A ⇒ C  →  A ⊗ B ⊢ C
r⊗⇒  :  A ⊗ B ⊢ C  →  B ⊢ A ⇒ C
r⇐⊗  :  A ⊢ C ⇐ B  →  A ⊗ B ⊢ C
r⊗⇐  :  A ⊗ B ⊢ C  →  A ⊢ C ⇐ B


-- Rules for (⇦ , ∘ , ⇨).
m∘   :  A ⊢ B  →  C ⊢ D  →  A ∘ C ⊢ B ∘ D
m⇨   :  A ⊢ B  →  C ⊢ D  →  B ⇨ C ⊢ A ⇨ D
m⇦   :  A ⊢ B  →  C ⊢ D  →  A ⇦ D ⊢ B ⇦ C
r⇨∘  :  B ⊢ A ⇨ C  →  A ∘ B ⊢ C
r∘⇨  :  A ∘ B ⊢ C  →  B ⊢ A ⇨ C
r⇦∘  :  A ⊢ C ⇦ B  →  A ∘ B ⊢ C
r∘⇦  :  A ∘ B ⊢ C  →  A ⊢ C ⇦ B


-- Rules for (I , L , R).
Iᵢ   :  A ∘ I ⊢ B  →  A ⊢ B
Iₑ   :  A ⊢ B  →  A ∘ I ⊢ B
Lᵢ   :  B ∘ ((L ⊗ A) ⊗ C) ⊢ D  →  A ⊗ (B ∘ C) ⊢ D
Lₑ   :  A ⊗ (B ∘ C) ⊢ D  →  B ∘ ((L ⊗ A) ⊗ C) ⊢ D
Rᵢ   :  A ∘ ((R ⊗ B) ⊗ C) ⊢ D  →  (A ∘ B) ⊗ C ⊢ D
Rₑ   :  (A ∘ B) ⊗ C ⊢ D  →  A ∘ ((R ⊗ B) ⊗ C) ⊢ D
