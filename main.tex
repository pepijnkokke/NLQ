\documentclass[a4paper]{article}

\input{preamble}

\begin{document}

\section{Introduction}

\subsection{What is type-logical grammar?}
Before we address the question of what type-logical grammar is, let us
look at the abstract pipeline for natural language understanding
in~\autoref{fig:abstract-nlu-pipeline}.
%
\input{fig-abstract-nlu-pipeline}%
%
To the left of the figure, you see the various phases or functions
commonly associated with an NLU-pipeline. To the right, you see the
inputs and outputs of these functions.
For instance, the morphological function will take an unanalysed
sentence, and return a sentence which is lemmatised and has all
morphemes made explicit (in the case of the example
in~\autoref{fig:abstract-nlu-pipeline}, \texttt{PAST} and
\texttt{PLURAL}).

There is some disagreement on the exact role of type-logical grammars in
this pipeline. Ideally, type-logical grammars would play the role of
both the syntactic and the semantic function. However, the current
state of affairs in research is that often only the semantic function
is truly considered\footnote{%
  This statement is not true for \emph{associative} type-logical
  grammars, which fundamentally treat the syntactic and semantic
  functions as the same function by rejecting the tree structure of
  sentences.
}. That is the approach I will also take in this thesis -- therefore,
we consider type-logical grammars to be the following function:
%
\begin{center}
  Mary:NP [see:TV.PAST fox:NP.PL]\\
  $\downarrow$\\
  \framebox{Type-Logical Grammar}\\
  $\downarrow$\\
  $\exists X.X\subseteq\mathbf{fox}\land\mathbf{past}(\mathbf{see}(\text{mary},X))$
\end{center}
%
The problem that the semantic function is trying to address is the
following:
%
\begin{center}\itshape
  Given a tree of words, compute the meaning of the overall tree.
\end{center}
%
The approach that type-logical grammar offers -- drawing heavily from
categorial grammar and Montague semantics -- is two-fold:
\begin{enumerate*}[label=(\arabic*)]
\item we use a simply-typed lambda calculus to represent lexical
  meaning, and compute the meanings sentences by compositionality,
  counting on decades of work on functional programming to aid us in
  the task of keeping seemingly non-compositional meanings
  compositional;
\item because this approach over-generates, we will use a second, more
  restricted type-theory which types only those utterances that are
  grammatical.
\end{enumerate*}

The process of meaning computation then becomes:
\begin{enumerate*}[label=(\arabic*)]
\item search for a proof of grammaticality in our syntactic calculus;
\item translate the found proof term to a lambda term in our semantic
  calculus.
\end{enumerate*}


\subsection{A simple type-logical grammar}
The simplest type-logical grammar that comes to mind is composed of
the simply-typed lambda calculus with atomic types \e\ and \t\ (\et1) as
a semantic calculus, and the non-associative Lambek calculus (NL) as a
syntactic calculus.

\subsubsection{A simple semantic calculus (\et1)}
The usual natural deduction formulation of \et1\ can to be seen
in~\autoref{fig:implicit-semantic-calculus}.
%
\input{fig-implicit-semantic-calculus}%
%
This formulation, however, uses a set of type assignments (of the form
$A : Î“$) as the antecedent, and therefore lacks a purely syntactic
definition.
%
If we \emph{do} want a purely syntactic definition, we will have to
give an equivalent formulation in which the structure that is implicit
in the set is made explicit. One such formulation can be seen
in~\autoref{fig:explicit-semantic-calculus}. We have replaced the
usual structural comma with a structural product ($\prod$), and added
five structural rules stating that we can freely change the order of
formulas (commutativity and associativity); copy formulas
(contraction); drop formulas (weakening); and always add the empty
structure (E$\emptyset$).

\subsubsection{A simple syntactic calculus (NL)}
\citet[p. 33, 105-106]{moot2012}

\input{fig-explicit-semantic-calculus}
\input{fig-syntactic-calculus}


%\input{fig-display-calculus}
%\input{fig-extension-lexical-ambiguity}
%\input{fig-extension-quantifier-raising}
%\input{fig-extension-scope-islands}

% - implicit semantic calculus;
% - explicit semantic calculus;
% - syntactic calculus;
% - display calculus;
% - compositionality principle;
% - problems with compositionality;
% - quantifier raising and scope ambiguity;
% - continuation monad & delimited continuations;
% - extension: lexical ambiguity;
% - extension: quantifier raising
%   * treatment of some & every;
%   * treatment of same & different;
%   * treatment of plurals;
% - extension: scope islands;

\bibliographystyle{apalike}%
\bibliography{main}%

\end{document}
