\documentclass[a4paper]{article}

\input{preamble}

\begin{document}

% ``We are constructing a \emph{grammar logic}. Therefore, we only
% want features in our logic for which we can demonstrate a motivating
% example from natural language.''

% - implicit semantic calculus;
% - explicit semantic calculus;
% - syntactic calculus;
% - display calculus;
% - compositionality principle;
% - problems with compositionality;
% - quantifier raising and scope ambiguity;
% - continuation monad & delimited continuations;
% - extension: lexical ambiguity;
% - extension: quantifier raising
%   * treatment of some & every;
%   * treatment of same & different;
%   * treatment of plurals;
% - extension: scope islands;

\include{introduction}
\include{display-calculus}
\include{lexical-ambiguity}
\include{natural-language-effects-and-movement}

\section{Movement and Quantifier Raising}%
\label{sec:movement-and-quantifier-raising}

In the previous section, we discussed the framework of monadic
semantics and extensible effects, and explained the limitations of
this framework for analysing quantification. In this section, we will
discuss the extensions made to the syntactic calculus NL, and see how
they can be used to analyse quantification. We will then giving our
own extensions, implemented in display NL, and show that they preserve
the properties we expect of a grammar logic (i.e. admissibility of
cut, and a decidable and complete proof search procedure).

In their \citeyear{barker2015} book, \citeauthor{barker2015} describe
an extension of NL which they call NL$_\lambda$. The main insight in
the formulation of this calculus was this: in type-logical grammar,
the antecedent encodes a constituency tree, therefore we can simply
encode quantifier raising in our logic.
\begin{center}
  \vspace*{0.5\baselineskip}
  \begin{minipage}{0.3\linewidth}
    \begin{tikzpicture}
      \Tree [ john [ likes everyone ] ]
    \end{tikzpicture}
  \end{minipage}%
  \begin{minipage}{0.02\linewidth}
    $\equiv$
  \end{minipage}%
  \begin{minipage}{0.4\linewidth}
    \begin{tikzpicture}
      \Tree [ everyone [ $\lambda x.$ [ john [ likes x ] ] ] ]
    \end{tikzpicture}
  \end{minipage}
\end{center}
To achieve this, they add a new mode to NL---that is to say, a copy of
the rules for $\{\impr,\prod,\impl\}$ applying to three new connectives
$\{\himpr,\hprod,\himpl\}$---and the following (somewhat controversial)
equivalence on structures:
\[
  \Sigma[\Delta]\equiv\Delta\circ\lambda x.\Sigma[x]
\]
This equivalence is intuitive, and works as expected. For instance,
using display NL extended with this equivalence, we can easily give a
derivation for ``John likes everyone,'' using the type
$\S\himpl(\NP\himpr\S)$ for quantifiers:
\begin{pfblock}
  \AXC{$\vdots$}\noLine
  \UIC{$\struct{\NP}\prod\struct{(\NP\impr\S)\impl\NP}\prod\struct{\NP}
    \fCenter\struct{\S}$}
  \RightLabel{$\lambda$}
  \UIC{$\struct{\NP}\hprod\lambda{x}.
    (\struct{\NP}\prod\struct{(\NP\impr\S)\impl\NP}\prod x)\fCenter\struct{\S}$}
  \RightLabel{Res$\hprod\himpr$}
  \UIC{$\lambda{x}.(\struct{\NP}\prod\struct{(\NP\impr\S)\impl\NP}\prod{x})
    \fCenter\struct{\NP}\himpr\struct{\S}$}
  \RightLabel{R$\himpr$}
  \UIC{$\lambda{x}.(\struct{\NP}\prod\struct{(\NP\impr\S)\impl\NP}\prod{x})
    \fCenter\struct{\NP\himpr\S}$}
  \AXC{}\RightLabel{Ax}\UIC{$\struct{S}\fCenter\struct{S}$}
  \BIC{$\struct{\S\himpl(\NP\himpr\S)}\fCenter\struct{\S}\himpl\lambda{x}.
    (\struct{\NP}\prod\struct{(\NP\impr\S)\impl\NP}\prod x)$}
  \RightLabel{Res$\himpl\:\hprod$}
  \UIC{$\struct{\S\himpl(\NP\himpr\S)}\hprod\lambda{x}.
    (\struct{\NP}\prod\struct{(\NP\impr\S)\impl\NP}\prod x)\fCenter\struct{\S}$}
  \RightLabel{$\lambda$}
  \UIC{$\struct{\NP}\prod\struct{(\NP\impr\S)\impl\NP}\prod\struct{\S\himpl
      (\NP\himpr\S)}\fCenter\struct{\S}$}
\end{pfblock}
However, the use of a binding construct in the syntax for structures
makes this equivalence quite difficult to formalise.
In addition, if we were to take the equivalence at face value, we
would end up with a logic in which we could do all kinds of unpleasant
things. For instance, since contexts are defined as structures with a
hole, we could raise quantifiers past one another, indefinitely:
\begin{pfblock}
  \AXC{$\vdots$}\noLine
  \UIC{$\struct{{\S\impl(\NP\impr\S)}}\hprod\lambda{z}.(\struct{{\S\impl(\NP\impr\S)}}\hprod\lambda{y}.({z}\hprod\lambda{x}.({y}\prod\struct{(\NP\impr\S)\impl\NP}\prod{x})))\fCenter\struct{\S}$}
  \RightLabel{$\lambda$}
  \UIC{$\struct{{\S\impl(\NP\impr\S)}}\hprod\lambda{y}.(\struct{{\S\impl(\NP\impr\S)}}\hprod\lambda{x}.({y}\prod\struct{(\NP\impr\S)\impl\NP}\prod{x}))\fCenter\struct{\S}$}
  \RightLabel{$\lambda$}
  \UIC{$\struct{{\S\impl(\NP\impr\S)}}\hprod\lambda{x}.(\struct{{\S\impl(\NP\impr\S)}}\prod\struct{(\NP\impr\S)\impl\NP}\prod{x})\fCenter\struct{\S}$}
  \RightLabel{$\lambda$}
  \UIC{$\struct{{\S\impl(\NP\impr\S)}}\prod\struct{(\NP\impr\S)\impl\NP}\prod\struct{{\S\impl(\NP\impr\S)}}\fCenter\struct{\S}$}
\end{pfblock}
Or, as \citet{barker2015} note, we could lift variables out of the
scope of their binder:
\begin{pfblock}
  \AXC{$\vdots$}\noLine
  \UIC{${x}\hprod\lambda{y}.(\struct{{\S\impl(\NP\impr\S)}}\hprod\lambda{x}.(\struct{{\S\impl(\NP\impr\S)}}\prod\struct{(\NP\impr\S)\impl\NP}\prod{y}))\fCenter\struct{\S}$}
  \RightLabel{$\lambda$}
  \UIC{$\struct{{\S\impl(\NP\impr\S)}}\hprod\lambda{x}.(\struct{{\S\impl(\NP\impr\S)}}\prod\struct{(\NP\impr\S)\impl\NP}\prod{x})\fCenter\struct{\S}$}
  \RightLabel{$\lambda$}
  \UIC{$\struct{{\S\impl(\NP\impr\S)}}\prod\struct{(\NP\impr\S)\impl\NP}\prod\struct{{\S\impl(\NP\impr\S)}}\fCenter\struct{\S}$}
\end{pfblock}
Needless to say, any logic extended with this equivalence loses a
number of pleasant properties, one of which is decidable proof
search. However, in chapter 17 of their book, \citeauthor{barker2015}
do a great job of capturing the essence of the $\lambda$-rule in a
logical manner; while their system is not yet decidable, it is very
nearly so. They extend NL by a second modality
$\{\himpr,\hprod,\himpl\}$, add three primitive structural constants
$\{\I,\B,\C\}$, and add the following structural rules:
\begin{center}
  \begin{pfbox}
    \AXC{$X\fCenter Y$}
    \doubleLine\RightLabel{\I}
    \UIC{$X\hprod\I\fCenter Y$}
  \end{pfbox}
  \begin{pfbox}
    \AXC{$X\prod(Y\hprod Z)\fCenter W$}
    \doubleLine\RightLabel{\B}
    \UIC{$Y\hprod((\B\prod X)\prod Z)\fCenter W$}
  \end{pfbox}
  \begin{pfbox}
    \AXC{$(X\prod Y)\hprod Z\fCenter W$}
    \doubleLine\RightLabel{\C}
    \UIC{$X\hprod((\C\prod Y)\prod Z)\fCenter W$}
  \end{pfbox}
\end{center}
They call the result NL$_{\text{CL}}$ (and, occasionally,
NL$_{\text{IBC}}$). In this calculus, quantifier raising can be done
in much the same way as in NL$_\lambda$---though the new version is
ever so slightly more verbose:\footnote{%
  Inverted applications of the \I, \B\ and \C\ rules are marked with a prime.
}
\begin{pfblock}
  \AXC{$\vdots$}\noLine
  \UIC{$\struct{\NP}\prod\struct{(\NP\impr\S)\impl\NP}\prod\struct{{\NP}}\fCenter\struct{{\S}}$}
  \RightLabel{Res$\prod\impr$}
  \UIC{$\struct{(\NP\impr\S)\impl\NP}\prod\struct{{\NP}}\fCenter\struct{\NP}\impr\struct{{\S}}$}
  \RightLabel{Res$\prod\impr$}
  \UIC{$\struct{{\NP}}\fCenter\struct{(\NP\impr\S)\impl\NP}\impr\struct{\NP}\impr\struct{{\S}}$}
  \RightLabel{\I}
  \UIC{$\struct{{\NP}}\hprod\I\fCenter\struct{(\NP\impr\S)\impl\NP}\impr\struct{\NP}\impr\struct{{\S}}$}
  \RightLabel{Res$\impr\prod$}
  \UIC{$\struct{(\NP\impr\S)\impl\NP}\prod(\struct{{\NP}}\hprod\I)\fCenter\struct{\NP}\impr\struct{{\S}}$}
  \RightLabel{\B}
  \UIC{$\struct{{\NP}}\prod((\B\prod\struct{(\NP\impr\S)\impl\NP})\prod\I)\fCenter\struct{\NP}\impr\struct{{\S}}$}
  \RightLabel{Res$\prod\impr$}
  \UIC{$\struct{\NP}\prod(\struct{{\NP}}\hprod((\B\prod\struct{(\NP\impr\S)\impl\NP})\prod\I))\fCenter\struct{{\S}}$}
  \RightLabel{\B}
  \UIC{$\struct{{\NP}}\hprod((\B\prod\struct{\NP})\prod((\B\prod\struct{(\NP\impr\S)\impl\NP})\prod\I))\fCenter\struct{{\S}}$}
  \RightLabel{Res$\hprod\himpr$}
  \UIC{$((\B\prod\struct{\NP})\prod((\B\prod\struct{(\NP\impr\S)\impl\NP})\prod\I))\fCenter\struct{{\NP}}\himpr\struct{{\S}}$}
  \RightLabel{R$\himpr$}
  \UIC{$((\B\prod\struct{\NP})\prod((\B\prod\struct{(\NP\impr\S)\impl\NP})\prod\I))\fCenter\struct{{\NP\himpr\S}}$}
  \AXC{}\RightLabel{Ax}\UIC{$\struct{\S}\fCenter\struct{{\S}}$}
  \RightLabel{L$\himpl$}
  \BIC{$\struct{{\S\himpl(\NP\himpr\S)}}\fCenter\struct{\S}\himpl((\B\prod\struct{\NP})\prod((\B\prod\struct{(\NP\impr\S)\impl\NP})\prod\I))$}
  \RightLabel{Res$\himpl\:\hprod$}
  \UIC{$\struct{{\S\himpl(\NP\himpr\S)}}\hprod((\B\prod\struct{\NP})\prod((\B\prod\struct{(\NP\impr\S)\impl\NP})\prod\I))\fCenter\struct{\S}$}
  \RightLabel{$\B'$}
  \UIC{$\struct{\NP}\prod(\struct{{\S\himpl(\NP\himpr\S)}}\hprod((\B\prod\struct{(\NP\impr\S)\impl\NP})\prod\I))\fCenter\struct{\S}$}
  \RightLabel{Res$\prod\impr$}
  \UIC{$\struct{{\S\himpl(\NP\himpr\S)}}\hprod((\B\prod\struct{(\NP\impr\S)\impl\NP})\prod\I)\fCenter\struct{\NP}\impr\struct{\S}$}
  \RightLabel{$\B'$}
  \UIC{$\struct{(\NP\impr\S)\impl\NP}\prod(\struct{{\S\himpl(\NP\himpr\S)}}\hprod\I)\fCenter\struct{\NP}\impr\struct{\S}$}
  \RightLabel{Res$\impr\prod$}
  \UIC{$\struct{{\S\himpl(\NP\himpr\S)}}\hprod\I\fCenter\struct{(\NP\impr\S)\impl\NP}\impr\struct{\NP}\impr\struct{\S}$}
  \RightLabel{$\I'$}
  \UIC{$\struct{{\S\himpl(\NP\himpr\S)}}\fCenter\struct{(\NP\impr\S)\impl\NP}\impr\struct{\NP}\impr\struct{\S}$}
  \RightLabel{Res$\prod\impr$}
  \UIC{$\struct{(\NP\impr\S)\impl\NP}\prod\struct{{\S\himpl(\NP\himpr\S)}}\fCenter\struct{\NP}\impr\struct{\S}$}
  \RightLabel{Res$\prod\impr$}
  \UIC{$\struct{\NP}\prod\struct{(\NP\impr\S)\impl\NP}\prod\struct{{\S\himpl(\NP\himpr\S)}}\fCenter\struct{\S}$}
\end{pfblock}
One of the advantages of this formalisation is that it gets rid of the
awkward binding construct in the syntax of structures. In addition, it
makes it clear that quantifiers can only move past \emph{solid}
products. However, it is not entirely free of problems. One of the
more glaring problems is that using this encoding, any expression can
be the subject of quantifier raising. For instance, in ``John likes
Mary,'' we could choose to raise the verb:
\begin{pfblock}
  \AXC{$\vdots$}\noLine
  \UIC{$\struct{{(\NP\impr\S)\impl\NP}}\hprod(\B\prod\struct{\NP})
    \prod((\C\prod\I)\prod\struct{\NP})\fCenter\struct{\S}$}\noLine
  \UIC{$\vdots$}\noLine
  \UIC{$\struct{\NP}\prod\struct{{(\NP\impr\S)\impl\NP}}\prod\struct{\NP}\fCenter\struct{\S}$}
\end{pfblock}
Since verbs are usually not considered scope-takers, it is unlikely
that raising the verb would lead to anything other then lowering it
again. However, the fact that we leave it open as an opportunity is
wasted computational effort; while all futile attempts at raising and
lowering will lead to a loop, and therefore spare us the spurious
ambiguity, there are still a great deal of futile attempts to be made.

Another problem is the $\I'$-rule. It allows us to introduce an
arbitrary amount of \I's, which causes a \emph{growing} loop in our
proof search procedure:
\begin{pfblock}
  \AXC{$\vdots$}\noLine
  \UIC{$((\struct{\NP}\prod\struct{\NP\impr\S})\hprod\I)\hprod\I\fCenter\struct{\S}$}
  \RightLabel{$\I'$}
  \UIC{$(\struct{\NP}\prod\struct{\NP\impr\S})\hprod\I\fCenter\struct{\S}$}
  \RightLabel{$\I'$}
  \UIC{$\struct{\NP}\prod\struct{\NP\impr\S}\fCenter\struct{\S}$}
\end{pfblock}
I propose to handle both of these issues with one simple addition. The
idea is to add a new unary connective, $\q[A]$, which represents a
license to perform quantifier raising. Since we want to replace the
problematic $\I'$-rule, we will choose the structural version of our
quantifying license to be a \emph{hollow} product with a right-hand
unit. On the other side, since we do not want logical products, we
will keep $\q[A]$ it as an atomic logical connective. This gives us
the following logical left rule:
\begin{pfblock}
  \AXC{$\struct{A}\hprod\I\fCenter Δ$}
  \RightLabel{L\I}
  \UIC{$\struct{\q[A]}\fCenter Δ$}
\end{pfblock}
The appropriate right rule is easily derived from the conventional
display calculus rules for products and units---though I do not imagine
we will generally want to see quantifying licenses in our output type:
\begin{pfblock}
  \AXC{$Γ\fCenter\struct{B}$}
  \RightLabel{R\I}
  \UIC{$Γ\hprod\I\fCenter\struct{\q[B]}$}
\end{pfblock}
And indeed, the pair obeys all constraints imposed by display
calculus, including a valid proof for \textbf{C8}:
\begin{pfblock}
  \AXC{$Γ\fCenter\struct{A}$}
  \AXC{$\struct{A}\hprod\I\fCenter Δ$}
  \RightLabel{Res$\hprod\himpl$}
  \UIC{$\struct{A}\fCenter Δ\himpl\I$}
  \RightLabel{Cut}
  \BIC{$Γ\fCenter Δ\himpl\I$}
  \RightLabel{Res$\himpl\hprod$}
  \UIC{$Γ\hprod\I\fCenter Δ$}
\end{pfblock}
Note that we keep the $\I$-rule, though we rename it $\I^-$ to
emphasise that it can now only \emph{remove} $\I$s. The full
extension, including semantics, and focused rules, can be found in
\autoref{fig:extension-quantifier-raising}. The semantics are rather
trivial: we simply translate all constants as units, and translate
$\q[A]$ as $A$, inserting and removing the right unit as needed.

\input{fig-extension-quantifier-raising}

The extension presented so far for quantifier raising is pretty good:
because we have removed all growing loops in structural rules, it now
has a decidable and complete procedure for proof search, and it neatly
captures quantifier movement---i.e. moving upwards, taking scope,
binding a variable, and moving that variable back down. However, it
still has one problem: spurious ambiguity. Imagine a sentence with two
quantifiers $P$ and $Q$, respectively \emph{one} and \emph{two} places
removed from the top of the syntax tree. The ambiguity that we want is
``do we raise $P$ first, or do we raise $Q$ first?'' However, in
addition to these possibilities, we now also have to possibility to
raise $Q$ one step, then raise $P$, and then raise $Q$ a second
step---semantically, this is equivalent to raising $P$, then
$Q$. NL$_\lambda$---if you only allow quantifier raising past solid
products---does not have this problem.

\citet[][chapter 17.6]{barker2015} examine the restrictions that need
to be put on the $\lambda$-rule in order to be able to translate
NL$_\lambda$ to NL$_{\text{CL}}$. In order to keep our structural
rules simple, and our calculus free of structural lambdas, I opt to go
the other way around, and see how close we can get to defining the
$\lambda$-rule in our calculus in \autoref{fig:extension-quantifier-raising}.
For this, we will need the following definitions:
\begin{center}
  $\text{Context}\;Σ\coloneqq\Box\vsep Σ\prodl Γ\vsep Γ\prodr Σ$\\
  \begin{minipage}{0.45\linewidth}
    \begin{alignat*}{2}
      &\Box       \;&&[Γ']\mapsto Γ'\\
      &(Σ\prodl Γ)\;&&[Γ']\mapsto (Σ[Γ']\prod Γ)\\
      &(Γ\prodr Σ)\;&&[Γ']\mapsto (Γ\prod Σ[Γ'])
    \end{alignat*}
  \end{minipage}
  \begin{minipage}{0.45\linewidth}
    \begin{alignat*}{2}
      &\trace(\Box)     \;&&\mapsto \mathbf{I}\\
      &\trace(Σ\prodl Γ)\;&&\mapsto ((\mathbf{C}\prod \trace(Σ))\prod Γ)\\
      &\trace(Γ\prodr Σ)\;&&\mapsto ((\mathbf{B}\prod Γ)\prod
      \trace(Σ))
    \end{alignat*}
  \end{minipage}
\end{center}
First we have contexts, which encode structures with a single hole,
where the nodes leading up to the hole are all solid
products---exactly the type of structure that quantifiers can move up
through. The syntax is a little abusive, as we use the same symbol for
products, products with a hole in their left argument, and products
with a hole in their right argument. However, as we require that
contexts have only a single hole, it is always unambiguous. Note that
products are right-associative.
Secondly, we have the plugging function `$\plug$', which inserts some
structure into the single hole in a context.
Lastly, the `trace' function computes, from a context, the trace of
$\B$s and $\C$s that would be left after something quantifies out of
that context.

Given these definitions, we can show that the following rule for
quantifier movement is admissible, by induction on the structure of
the context:
\begin{pfblock}
  \AXC{$\struct{A}\hprod\trace(Σ)\fCenter Δ$}
  \doubleLine\RightLabel{$\uparrow\downarrow$}
  \UIC{$Σ[\struct{\q[A]}]\fCenter Δ$}
\end{pfblock}
This new rule is very close to \citeauthor{barker2015}'s equivalence,
with as its only difference that the quantifying license is now built
into it:
\[
  \Sigma[\Delta]\equiv\Delta\circ\lambda x.\Sigma[x]
  \qquad
  Σ[\struct{\q[A]}]\equiv\struct{A}\hprod\trace(Σ)
\]
In fact, if you read products as function applications, and the
constants $\{\I,\B,\C\}$ as the combinators, as \citet{barker2015}
intended, then the right-hand side expressions are more-or-less
equivalent.\footnote{%
  As an aside: what we set out to encode were contexts with holes that
  are unique---plugging should never duplicate or forget
  information. So the $\lambda$-terms in NL$_\lambda$ were implicitly
  linear. The combinators $\I$, $\B$ and $\C$ correspond precisely to
  the linear lambda calculus. However, the combinator language is far
  easier to encode than linear binding constructs.
}
Proof search with this derived rule is still complete; it merely
enforces that the entire quantifier raising or lowering is done in one
go.\todo{No proof.}

In their discussion of decidability, \citet{barker2015} derive the
`expansion' and `reduction' rules which more-or-less correspond to
the two directions of the equivalence, or the two directions of our
$\uparrow\downarrow$-rule. They then combine these rules with
L$\himpl$ and R$\himpr$, respectively, yielding the
$\himpl\,\text{L}_\lambda$ and $\himpr\text{R}_\lambda$ rules. The
advantage of these combined rules is that they obey the sub-formula
property, and are therefore suited to naive backward-chaining proof
search. We can do a similar thing using our $\uparrow\downarrow$-rule:
\begin{center}
  \begin{pfbox}
    \AXC{$\trace(Σ)\fCenter\struct{A\himpr B}$} \AXC{$\struct{C}\fCenter Δ$}
    \RightLabel{\qup}
    \BIC{$Σ[\struct{\q[C\himpl(A\himpr B)]}]\fCenter Δ$}
  \end{pfbox}
  \begin{pfbox}
    \AXC{$Σ[\struct{A}]\fCenter\struct{B}$}
    \RightLabel{\qdown}
    \UIC{$\trace(Σ)\fCenter\struct{A\himpr B}$}
  \end{pfbox}
\end{center}
While proof search with these rules is decidable, it is no longer
complete. However, it \emph{is} complete for the fragment of display
NL where all types involving a quantifying license are of the form
$\q[C\himpl(A\himpr B)]$, which is what we can reasonably expect from
natural language.
In addition, proof search using these rules is no longer plagued by
the spurious ambiguity that resulted from the $\B$ and $\C$
rules---and, to boot, we can write proofs involving quantifier
movement in a much more succinct manner:
\begin{pfblock}
  \AXC{$\vdots$}\noLine
  \UIC{$\struct{\NP}\prod\textsc{loves}\prod\struct{\NP}\fCenter\struct{\S}$}
  \RightLabel{\qdown}
  \UIC{$\trace(\Box\prod\textsc{loves}\prod\struct{\NP})\fCenter\struct{{\NP\himpr\S}}$}
  \AXC{}\RightLabel{Ax}\UIC{$\struct{\S}\fCenter\struct{\S}$}
  \RightLabel{\qup}
  \BIC{$\textsc{everyone}\prod\textsc{loves}\prod\struct{\NP}\fCenter\struct{\S}$}
  \RightLabel{\qdown}
  \UIC{$\trace(\textsc{everyone}\prod\textsc{loves}\prod\Box)\fCenter\struct{{\NP\himpr\S}}$}
  \AXC{}\RightLabel{Ax}\UIC{$\struct{\S}\fCenter\struct{\S}$}
  \RightLabel{\qup}
  \BIC{$\textsc{everyone}\prod\textsc{loves}\prod\textsc{someone}\fCenter\struct{\S}$}
\end{pfblock}
\vspace*{-1\baselineskip}
\begin{gather*}
  \downmapsto
  \\
  (\someone\;(\lambda y. \everyone\;(\lambda x.\likes\;y\;x)))
  \\
  \downmapsto
  \\
  \exists y.\PERSON(y)\wedge\forall x.\PERSON(x)\supset\LIKE(x,y)
\end{gather*}
Note that though we have the option, we do not have to unfold the
application of `trace' in this particular proof. In future proofs, if
we choose to fold or unfold an application of `trace', we will
explicitly mark this as an application of rewriting by equality
(`$=$').

\input{fig-example-changing-answer-type}

\paragraph{Parasitic scope}
The system described in \autoref{fig:extension-quantifier-raising}
maintains the decomposition of the quantifier movement into two
separate functions---raising and lowering. Therefore, we can still
analyse parasitic scope \citep{barker2007}. In
\autoref{fig:parasitic-scope}, we analyse a classic example of
parasitic scope for \emph{different}: ``A different waiter served
everyone.'' However, we make one small change to the type of
`different', in order to obtain the semantics described by
\citet{kiselyov2015b}. We use the lexicon described below:
\[
  \renewcommand*{\arraystretch}{1}
  \begin{array}{l c l}
    \multirow{2}{*}{\a}
    &:& \tr[{(\q[\S\himpl(\NP\himpr\S)]\impl\N)}]\\
    &=& \lambda n. \lambda k. \exists x. n\;x\wedge k\;x\\

    \multirow{2}{*}{\different}
    &:& \tr[{(\q[\S\himpl(\q[(\NP\himpr\S)\himpl(\A\himpr(\NP\himpr\S))]\himpr\S)])}]\\
    &=& \lambda k. \exists f. (\forall x.\forall y.\nexists z.f\;z\;x\wedge f\;z\;y)\;\wedge\\
    & & k\;(\lambda k'.\lambda x.k'\;(\lambda g.\lambda y.g\;y\wedge f\;x\;y)\;x)\\

    \multirow{2}{*}{\waiter}
    &:& \tr[\N]\\
    &=& \lambda x.\WAITER(x)\\

    \multirow{2}{*}{\served}
    &:& \tr[\TV]\\
    &=& \lambda y.\lambda x.\PAST(\SERVE(x,y))\\

    \multirow{2}{*}{\everyone}
    &:& \tr[{(\q[\S\himpl(\NP\himpr\S)])}]\\
    &=& \lambda k.\forall x.\PERSON(x)\supset k\;x
  \end{array}
\]
It may be worthwhile to have a closer look at the type for
`different.' It is a quantifier taking scope at the sentence
level ${\q[\S\himpl(\ldots\himpr\S)]}$, which becomes a quantifier
taking scope parasitically ${\q[(\NP\himpr\S)\himpl(\ldots
\himpr(\NP\himpr\S))]}$, and finally becomes an adjective $\A$.

The double quantification in `different' has some very interesting
effects. Because it takes scope normally and then parasitically the
sentence ``A different waiter served everyone'' is unambiguous, even
though it contains no fewer than \emph{three} quantifiers. This is
because of the dependencies between the quantifiers: `a' cannot take
scope until it receives its noun argument, which is modified by
`different'. Meanwhile, `different' has to take scope twice, once
normally and once parasitically. Its parasitic scope-taking has to
occur \emph{while} `everyone' is taking scope, so its normal
scope-taking has to occur before that.
On the semantic level, double quantification allows a quantifier to
capture another quantifier while \emph{also} taking scope over it.

\input{fig-example-parasitic-scope}


\paragraph{Scope islands}






\input{fig-extension-scope-islands}



%\input{fig-extension-infixation}
%\input{fig-extension-extraction}

\include{future-work}


\bibliographystyle{apalike}
\bibliography{main}%

\end{document}
