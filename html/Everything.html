<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >Everything</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta http-equiv="Content-Style-Type" content="text/css"
     /><link href="Agda.css" rel="stylesheet" type="text/css"
     /></head
  ><body
  ><pre
    ><a name="1" class="Comment"
      >------------------------------------------------------------------------</a
      ><a name="73"
      >
</a
      ><a name="74" class="Comment"
      >-- The Lambek Calculus in Agda</a
      ><a name="104"
      >
</a
      ><a name="105" class="Comment"
      >------------------------------------------------------------------------</a
      ><a name="177"
      >

</a
      ><a name="179" class="Keyword"
      >module</a
      ><a name="185"
      > </a
      ><a name="186" href="Everything.html#1" class="Module"
      >Everything</a
      ><a name="196"
      > </a
      ><a name="197" class="Keyword"
      >where</a
      ><a name="202"
      >

</a
      ><a name="204" class="Comment"
      >-- Defines a residuated algebra, which I've taken to be:</a
      ><a name="260"
      >
</a
      ><a name="261" class="Comment"
      >--</a
      ><a name="263"
      >
</a
      ><a name="264" class="Comment"
      >-- (1) a residuated ordered monoid without associativity, or</a
      ><a name="324"
      >
</a
      ><a name="325" class="Comment"
      >-- (2) an algebra which adds a partial order and a left and right</a
      ><a name="390"
      >
</a
      ><a name="391" class="Comment"
      >--     residuation operation. Congruence of the binary operator &#8729;</a
      ><a name="456"
      >
</a
      ><a name="457" class="Comment"
      >--     results from its compatibility with the partial order &#8804;.</a
      ><a name="520"
      >
</a
      ><a name="521" class="Comment"
      >--</a
      ><a name="523"
      >
</a
      ><a name="524" class="Keyword"
      >import</a
      ><a name="530"
      > </a
      ><a name="531" href="Algebra.ResiduatedAlgebra.html#1" class="Module"
      >Algebra.ResiduatedAlgebra</a
      ><a name="556"
      >

</a
      ><a name="558" class="Comment"
      >-- Definitions categories and functors.</a
      ><a name="597"
      >
</a
      ><a name="598" class="Keyword"
      >import</a
      ><a name="604"
      > </a
      ><a name="605" href="Categories.html#1" class="Module"
      >Categories</a
      ><a name="615"
      >

</a
      ><a name="617" class="Keyword"
      >import</a
      ><a name="623"
      > </a
      ><a name="624" href="Logic.Lambek.NaturalDeduction.Base.html#1" class="Module"
      >Logic.Lambek.NaturalDeduction.Base</a
      ><a name="658"
      >

</a
      ><a name="660" class="Keyword"
      >import</a
      ><a name="666"
      > </a
      ><a name="667" href="Logic.Lambek.NaturalDeduction.Complete.html#1" class="Module"
      >Logic.Lambek.NaturalDeduction.Complete</a
      ><a name="705"
      >

</a
      ><a name="707" class="Keyword"
      >import</a
      ><a name="713"
      > </a
      ><a name="714" href="Logic.Lambek.NaturalDeduction.EquivalentToResMon.html#1" class="Module"
      >Logic.Lambek.NaturalDeduction.EquivalentToResMon</a
      ><a name="762"
      >

</a
      ><a name="764" class="Keyword"
      >import</a
      ><a name="770"
      > </a
      ><a name="771" href="Logic.Lambek.ResMon.html#1" class="Module"
      >Logic.Lambek.ResMon</a
      ><a name="790"
      >

</a
      ><a name="792" class="Keyword"
      >import</a
      ><a name="798"
      > </a
      ><a name="799" href="Logic.Lambek.ResMon.Base.html#1" class="Module"
      >Logic.Lambek.ResMon.Base</a
      ><a name="823"
      >

</a
      ><a name="825" class="Comment"
      >-- Proof of completeness of the residuation-monotonicity calculus w.r.t.</a
      ><a name="897"
      >
</a
      ><a name="898" class="Comment"
      >-- residuated algebras (or Lambek algebras).</a
      ><a name="942"
      >
</a
      ><a name="943" class="Keyword"
      >import</a
      ><a name="949"
      > </a
      ><a name="950" href="Logic.Lambek.ResMon.Complete.html#1" class="Module"
      >Logic.Lambek.ResMon.Complete</a
      ><a name="978"
      >

</a
      ><a name="980" class="Comment"
      >-- Implements derivations---also known as partial proofs or term</a
      ><a name="1044"
      >
</a
      ><a name="1045" class="Comment"
      >-- contexts---which are generally written as:</a
      ><a name="1090"
      >
</a
      ><a name="1091" class="Comment"
      >--</a
      ><a name="1093"
      >
</a
      ><a name="1094" class="Comment"
      >--     A &#8866; B</a
      ><a name="1106"
      >
</a
      ><a name="1107" class="Comment"
      >--     -----</a
      ><a name="1119"
      >
</a
      ><a name="1120" class="Comment"
      >--       &#8942;</a
      ><a name="1130"
      >
</a
      ><a name="1131" class="Comment"
      >--     -----</a
      ><a name="1143"
      >
</a
      ><a name="1144" class="Comment"
      >--     C &#8866; D</a
      ><a name="1156"
      >
</a
      ><a name="1157" class="Comment"
      >--</a
      ><a name="1159"
      >
</a
      ><a name="1160" class="Comment"
      >-- This definition guarantees that there is exactly *one* sub-proof</a
      ><a name="1227"
      >
</a
      ><a name="1228" class="Comment"
      >-- missing. In addition, this module provides proofs that these</a
      ><a name="1291"
      >
</a
      ><a name="1292" class="Comment"
      >-- contexts form a category, and thus behave function-like.</a
      ><a name="1351"
      >
</a
      ><a name="1352" class="Keyword"
      >import</a
      ><a name="1358"
      > </a
      ><a name="1359" href="Logic.Lambek.ResMon.Derivation.html#1" class="Module"
      >Logic.Lambek.ResMon.Derivation</a
      ><a name="1389"
      >

</a
      ><a name="1391" class="Keyword"
      >import</a
      ><a name="1397"
      > </a
      ><a name="1398" href="Logic.Lambek.ResMon.Judgement.html#1" class="Module"
      >Logic.Lambek.ResMon.Judgement</a
      ><a name="1427"
      >

</a
      ><a name="1429" class="Keyword"
      >import</a
      ><a name="1435"
      > </a
      ><a name="1436" href="Logic.Lambek.ResMon.Judgement.Context.html#1" class="Module"
      >Logic.Lambek.ResMon.Judgement.Context</a
      ><a name="1473"
      >

</a
      ><a name="1475" class="Keyword"
      >import</a
      ><a name="1481"
      > </a
      ><a name="1482" href="Logic.Lambek.ResMon.Judgement.Context.Polarised.html#1" class="Module"
      >Logic.Lambek.ResMon.Judgement.Context.Polarised</a
      ><a name="1529"
      >

</a
      ><a name="1531" class="Comment"
      >-- Implements several views on proofs in the system ResMon which are</a
      ><a name="1599"
      >
</a
      ><a name="1600" class="Comment"
      >-- heavily used in the proof of admissibility of the transitivity rule.</a
      ><a name="1671"
      >
</a
      ><a name="1672" class="Comment"
      >--</a
      ><a name="1674"
      >
</a
      ><a name="1675" class="Comment"
      >-- One advantage of the residuation-monotonicity calculus is that</a
      ><a name="1740"
      >
</a
      ><a name="1741" class="Comment"
      >-- every connective *must* be introduced by an application of the</a
      ><a name="1806"
      >
</a
      ><a name="1807" class="Comment"
      >-- corresponding monotonicity-rule. The proofs in the `Origin` module</a
      ><a name="1876"
      >
</a
      ><a name="1877" class="Comment"
      >-- can be used to construct a view on a proof that makes this</a
      ><a name="1938"
      >
</a
      ><a name="1939" class="Comment"
      >-- introducing application of a monotonicity-rule explicit.</a
      ><a name="1998"
      >
</a
      ><a name="1999" class="Comment"
      >--</a
      ><a name="2001"
      >
</a
      ><a name="2002" class="Comment"
      >-- The proofs in this module are highly repetitive, and the decision</a
      ><a name="2070"
      >
</a
      ><a name="2071" class="Comment"
      >-- procedures and data structures could be abstracted over by</a
      ><a name="2132"
      >
</a
      ><a name="2133" class="Comment"
      >-- generalising over the connectives (cutting the file length by &#177;750</a
      ><a name="2202"
      >
</a
      ><a name="2203" class="Comment"
      >-- lines). However, I feel that abstracting over connectives would</a
      ><a name="2269"
      >
</a
      ><a name="2270" class="Comment"
      >-- make the logic a lot harder to read. I may do it in the future</a
      ><a name="2335"
      >
</a
      ><a name="2336" class="Comment"
      >-- anyway.</a
      ><a name="2346"
      >
</a
      ><a name="2347" class="Keyword"
      >import</a
      ><a name="2353"
      > </a
      ><a name="2354" href="Logic.Lambek.ResMon.Origin.html#1" class="Module"
      >Logic.Lambek.ResMon.Origin</a
      ><a name="2380"
      >

</a
      ><a name="2382" class="Keyword"
      >import</a
      ><a name="2388"
      > </a
      ><a name="2389" href="Logic.Lambek.ResMon.Trans.html#1" class="Module"
      >Logic.Lambek.ResMon.Trans</a
      ><a name="2414"
      >

</a
      ><a name="2416" class="Keyword"
      >import</a
      ><a name="2422"
      > </a
      ><a name="2423" href="Logic.Lambek.SC.html#1" class="Module"
      >Logic.Lambek.SC</a
      ><a name="2438"
      >

</a
      ><a name="2440" class="Comment"
      >-- Implements the axioms and some derived inference rules.</a
      ><a name="2498"
      >
</a
      ><a name="2499" class="Keyword"
      >import</a
      ><a name="2505"
      > </a
      ><a name="2506" href="Logic.Lambek.SC.Base.html#1" class="Module"
      >Logic.Lambek.SC.Base</a
      ><a name="2526"
      >

</a
      ><a name="2528" class="Keyword"
      >import</a
      ><a name="2534"
      > </a
      ><a name="2535" href="Logic.Lambek.SC.Complete.html#1" class="Module"
      >Logic.Lambek.SC.Complete</a
      ><a name="2559"
      >

</a
      ><a name="2561" class="Comment"
      >-- Implements a proof of equivalence with the residuation-monotonicity</a
      ><a name="2631"
      >
</a
      ><a name="2632" class="Comment"
      >-- calculus as `ResMon&#8660;SC`.</a
      ><a name="2659"
      >
</a
      ><a name="2660" class="Keyword"
      >import</a
      ><a name="2666"
      > </a
      ><a name="2667" href="Logic.Lambek.SC.EquivalentToResMon.html#1" class="Module"
      >Logic.Lambek.SC.EquivalentToResMon</a
      ><a name="2701"
      >

</a
      ><a name="2703" class="Comment"
      >-- Implements the axioms and some derived inference rules.</a
      ><a name="2761"
      >
</a
      ><a name="2762" class="Keyword"
      >import</a
      ><a name="2768"
      > </a
      ><a name="2769" href="Logic.Lambek.SC.Judgement.html#1" class="Module"
      >Logic.Lambek.SC.Judgement</a
      ><a name="2794"
      >

</a
      ><a name="2796" class="Comment"
      >-- Uses the equivalence relation between SC and the</a
      ><a name="2847"
      >
</a
      ><a name="2848" class="Comment"
      >-- residuation-monotonicity axiomatisations to import the proof of</a
      ><a name="2914"
      >
</a
      ><a name="2915" class="Comment"
      >-- transitivity into SC.</a
      ><a name="2939"
      >
</a
      ><a name="2940" class="Keyword"
      >import</a
      ><a name="2946"
      > </a
      ><a name="2947" href="Logic.Lambek.SC.Trans.html#1" class="Module"
      >Logic.Lambek.SC.Trans</a
      ><a name="2968"
      >

</a
      ><a name="2970" class="Keyword"
      >import</a
      ><a name="2976"
      > </a
      ><a name="2977" href="Logic.Lambek.Type.html#1" class="Module"
      >Logic.Lambek.Type</a
      ><a name="2994"
      >

</a
      ><a name="2996" class="Keyword"
      >import</a
      ><a name="3002"
      > </a
      ><a name="3003" href="Logic.Lambek.Type.Complexity.html#1" class="Module"
      >Logic.Lambek.Type.Complexity</a
      ><a name="3031"
      >

</a
      ><a name="3033" class="Keyword"
      >import</a
      ><a name="3039"
      > </a
      ><a name="3040" href="Logic.Lambek.Type.Context.html#1" class="Module"
      >Logic.Lambek.Type.Context</a
      ><a name="3065"
      >

</a
      ><a name="3067" class="Keyword"
      >import</a
      ><a name="3073"
      > </a
      ><a name="3074" href="Logic.Lambek.Type.Context.Polarised.html#1" class="Module"
      >Logic.Lambek.Type.Context.Polarised</a
      ><a name="3109"
      >

</a
      ><a name="3111" class="Keyword"
      >import</a
      ><a name="3117"
      > </a
      ><a name="3118" href="Logic.LambekGrishin.ResMon.html#1" class="Module"
      >Logic.LambekGrishin.ResMon</a
      ><a name="3144"
      >

</a
      ><a name="3146" class="Keyword"
      >import</a
      ><a name="3152"
      > </a
      ><a name="3153" href="Logic.LambekGrishin.ResMon.Base.html#1" class="Module"
      >Logic.LambekGrishin.ResMon.Base</a
      ><a name="3184"
      >

</a
      ><a name="3186" class="Comment"
      >-- Implements derivations---also known as partial proofs or term</a
      ><a name="3250"
      >
</a
      ><a name="3251" class="Comment"
      >-- contexts---which are generally written as:</a
      ><a name="3296"
      >
</a
      ><a name="3297" class="Comment"
      >--</a
      ><a name="3299"
      >
</a
      ><a name="3300" class="Comment"
      >--     A &#8866; B</a
      ><a name="3312"
      >
</a
      ><a name="3313" class="Comment"
      >--     -----</a
      ><a name="3325"
      >
</a
      ><a name="3326" class="Comment"
      >--       &#8942;</a
      ><a name="3336"
      >
</a
      ><a name="3337" class="Comment"
      >--     -----</a
      ><a name="3349"
      >
</a
      ><a name="3350" class="Comment"
      >--     C &#8866; D</a
      ><a name="3362"
      >
</a
      ><a name="3363" class="Comment"
      >--</a
      ><a name="3365"
      >
</a
      ><a name="3366" class="Comment"
      >-- This definition guarantees that there is exactly *one* sub-proof</a
      ><a name="3433"
      >
</a
      ><a name="3434" class="Comment"
      >-- missing. In addition, this module provides proofs that these</a
      ><a name="3497"
      >
</a
      ><a name="3498" class="Comment"
      >-- contexts form a category, and thus behave function-like.</a
      ><a name="3557"
      >
</a
      ><a name="3558" class="Keyword"
      >import</a
      ><a name="3564"
      > </a
      ><a name="3565" href="Logic.LambekGrishin.ResMon.Derivation.html#1" class="Module"
      >Logic.LambekGrishin.ResMon.Derivation</a
      ><a name="3602"
      >

</a
      ><a name="3604" class="Keyword"
      >import</a
      ><a name="3610"
      > </a
      ><a name="3611" href="Logic.LambekGrishin.ResMon.Judgement.html#1" class="Module"
      >Logic.LambekGrishin.ResMon.Judgement</a
      ><a name="3647"
      >

</a
      ><a name="3649" class="Keyword"
      >import</a
      ><a name="3655"
      > </a
      ><a name="3656" href="Logic.LambekGrishin.ResMon.Judgement.Context.html#1" class="Module"
      >Logic.LambekGrishin.ResMon.Judgement.Context</a
      ><a name="3700"
      >

</a
      ><a name="3702" class="Keyword"
      >import</a
      ><a name="3708"
      > </a
      ><a name="3709" href="Logic.LambekGrishin.ResMon.Judgement.Context.Polarised.html#1" class="Module"
      >Logic.LambekGrishin.ResMon.Judgement.Context.Polarised</a
      ><a name="3763"
      >

</a
      ><a name="3765" class="Comment"
      >-- Implements several views on proofs in the system ResMon which are</a
      ><a name="3833"
      >
</a
      ><a name="3834" class="Comment"
      >-- heavily used in the proof of admissibility of the transitivity rule.</a
      ><a name="3905"
      >
</a
      ><a name="3906" class="Comment"
      >--</a
      ><a name="3908"
      >
</a
      ><a name="3909" class="Comment"
      >-- One advantage of the residuation-monotonicity calculus is that</a
      ><a name="3974"
      >
</a
      ><a name="3975" class="Comment"
      >-- every connective *must* be introduced by an application of the</a
      ><a name="4040"
      >
</a
      ><a name="4041" class="Comment"
      >-- corresponding monotonicity-rule. The proofs in the `Origin` module</a
      ><a name="4110"
      >
</a
      ><a name="4111" class="Comment"
      >-- can be used to construct a view on a proof that makes this</a
      ><a name="4172"
      >
</a
      ><a name="4173" class="Comment"
      >-- introducing application of a monotonicity-rule explicit.</a
      ><a name="4232"
      >
</a
      ><a name="4233" class="Comment"
      >--</a
      ><a name="4235"
      >
</a
      ><a name="4236" class="Comment"
      >-- The proofs in this module are highly repetitive, and the decision</a
      ><a name="4304"
      >
</a
      ><a name="4305" class="Comment"
      >-- procedures and data structures could be abstracted over by</a
      ><a name="4366"
      >
</a
      ><a name="4367" class="Comment"
      >-- generalising over the connectives (cutting the file length by &#177;750</a
      ><a name="4436"
      >
</a
      ><a name="4437" class="Comment"
      >-- lines). However, I feel that abstracting over connectives would</a
      ><a name="4503"
      >
</a
      ><a name="4504" class="Comment"
      >-- make the logic a lot harder to read. I may do it in the future</a
      ><a name="4569"
      >
</a
      ><a name="4570" class="Comment"
      >-- anyway.</a
      ><a name="4580"
      >
</a
      ><a name="4581" class="Keyword"
      >import</a
      ><a name="4587"
      > </a
      ><a name="4588" href="Logic.LambekGrishin.ResMon.Origin.html#1" class="Module"
      >Logic.LambekGrishin.ResMon.Origin</a
      ><a name="4621"
      >

</a
      ><a name="4623" class="Keyword"
      >import</a
      ><a name="4629"
      > </a
      ><a name="4630" href="Logic.LambekGrishin.ResMon.Trans.html#1" class="Module"
      >Logic.LambekGrishin.ResMon.Trans</a
      ><a name="4662"
      >

</a
      ><a name="4664" class="Keyword"
      >import</a
      ><a name="4670"
      > </a
      ><a name="4671" href="Logic.LambekGrishin.Type.html#1" class="Module"
      >Logic.LambekGrishin.Type</a
      ><a name="4695"
      >

</a
      ><a name="4697" class="Keyword"
      >import</a
      ><a name="4703"
      > </a
      ><a name="4704" href="Logic.LambekGrishin.Type.Complexity.html#1" class="Module"
      >Logic.LambekGrishin.Type.Complexity</a
      ><a name="4739"
      >

</a
      ><a name="4741" class="Keyword"
      >import</a
      ><a name="4747"
      > </a
      ><a name="4748" href="Logic.LambekGrishin.Type.Context.html#1" class="Module"
      >Logic.LambekGrishin.Type.Context</a
      ><a name="4780"
      >

</a
      ><a name="4782" class="Keyword"
      >import</a
      ><a name="4788"
      > </a
      ><a name="4789" href="Logic.LambekGrishin.Type.Context.Polarised.html#1" class="Module"
      >Logic.LambekGrishin.Type.Context.Polarised</a
      ><a name="4831"
      >

</a
      ><a name="4833" class="Keyword"
      >import</a
      ><a name="4839"
      > </a
      ><a name="4840" href="Logic.LambekGrishin.Type.Polarised.html#1" class="Module"
      >Logic.LambekGrishin.Type.Polarised</a
      ><a name="4874"
      >

</a
      ><a name="4876" class="Keyword"
      >import</a
      ><a name="4882"
      > </a
      ><a name="4883" href="Logic.Linear.LambekVanBenthem.Base.html#1" class="Module"
      >Logic.Linear.LambekVanBenthem.Base</a
      ><a name="4917"
      >

</a
      ><a name="4919" class="Keyword"
      >import</a
      ><a name="4925"
      > </a
      ><a name="4926" href="Logic.Linear.LambekVanBenthem.Judgement.html#1" class="Module"
      >Logic.Linear.LambekVanBenthem.Judgement</a
      ><a name="4965"
      >

</a
      ><a name="4967" class="Keyword"
      >import</a
      ><a name="4973"
      > </a
      ><a name="4974" href="Logic.Linear.LambekVanBenthem.Judgement.Context.html#1" class="Module"
      >Logic.Linear.LambekVanBenthem.Judgement.Context</a
      ><a name="5021"
      >

</a
      ><a name="5023" class="Keyword"
      >import</a
      ><a name="5029"
      > </a
      ><a name="5030" href="Logic.Linear.LambekVanBenthem.Judgement.Context.Polarised.html#1" class="Module"
      >Logic.Linear.LambekVanBenthem.Judgement.Context.Polarised</a
      ><a name="5087"
      >

</a
      ><a name="5089" class="Keyword"
      >import</a
      ><a name="5095"
      > </a
      ><a name="5096" href="Logic.Linear.Type.html#1" class="Module"
      >Logic.Linear.Type</a
      ><a name="5113"
      >

</a
      ><a name="5115" class="Keyword"
      >import</a
      ><a name="5121"
      > </a
      ><a name="5122" href="Logic.Linear.Type.Complexity.html#1" class="Module"
      >Logic.Linear.Type.Complexity</a
      ><a name="5150"
      >

</a
      ><a name="5152" class="Keyword"
      >import</a
      ><a name="5158"
      > </a
      ><a name="5159" href="Logic.Linear.Type.Context.html#1" class="Module"
      >Logic.Linear.Type.Context</a
      ><a name="5184"
      >

</a
      ><a name="5186" class="Keyword"
      >import</a
      ><a name="5192"
      > </a
      ><a name="5193" href="Logic.Linear.Type.Context.Polarised.html#1" class="Module"
      >Logic.Linear.Type.Context.Polarised</a
      ><a name="5228"
      >

</a
      ><a name="5230" class="Keyword"
      >import</a
      ><a name="5236"
      > </a
      ><a name="5237" href="Logic.Polarity.html#1" class="Module"
      >Logic.Polarity</a
      ><a name="5251"
      >

</a
      ><a name="5253" class="Keyword"
      >import</a
      ><a name="5259"
      > </a
      ><a name="5260" href="Logic.Reification.html#1" class="Module"
      >Logic.Reification</a
      ><a name="5277"
      >

</a
      ><a name="5279" class="Keyword"
      >import</a
      ><a name="5285"
      > </a
      ><a name="5286" href="Main.html#1" class="Module"
      >Main</a
      ><a name="5290"
      >

</a
      ><a name="5292" class="Comment"
      >-- A utility module which constructs an equivalence relation from a</a
      ><a name="5359"
      >
</a
      ><a name="5360" class="Comment"
      >-- partial order. This requires some tricks, as the Agda standard</a
      ><a name="5425"
      >
</a
      ><a name="5426" class="Comment"
      >-- library defines orders based on equivalences. Therefore, instead of</a
      ><a name="5496"
      >
</a
      ><a name="5497" class="Comment"
      >-- requiring an instance of the poset class, this module requires an</a
      ><a name="5565"
      >
</a
      ><a name="5566" class="Comment"
      >-- order together with proof of identity and transitivity, and defines</a
      ><a name="5636"
      >
</a
      ><a name="5637" class="Comment"
      >-- an equivalence relation, and a complete instance of the poset class.</a
      ><a name="5708"
      >
</a
      ><a name="5709" class="Keyword"
      >import</a
      ><a name="5715"
      > </a
      ><a name="5716" href="Relation.Binary.PartialOrderToEquivalence.html#1" class="Module"
      >Relation.Binary.PartialOrderToEquivalence</a
      ><a name="5757"
      >
</a
      ></pre
    ></body
  ></html
>
